---
title: "Metadata"
description: "Metadata is the foundation of deterministic retrieval in Cortex."
---

Semantic and graph-based recall are powerful, but production systems still need explicit control: filter by owner, project, team, time range, source, compliance scope, or any custom logic.

Cortex metadata lets you **structure, scope, and constrain** recall — so your agents retrieve the right context _on purpose_, not by luck.

> Mental model: **Metadata defines the search space. Cortex recall ranks what matters inside it.**

---

## Where Metadata Is Used

- **Ingestion / Upload**: attach metadata at the time you add knowledge or documents.
- **Recall & Search**: apply metadata filters to deterministically include/exclude results.
- **Ranking**: metadata can also act as a scoring signal (e.g., boost approved docs).

**Note:** For uploads, use `tenant_metadata` and `document_metadata` (same schema as the original `metadata` field). These fields are not used in the QnA endpoint.

---

## Two-Tier Metadata Architecture

Cortex supports two tiers of metadata for enterprise-scale systems.

### Tenant Metadata (`tenant_metadata`)

Organization-level metadata that applies consistently across everything in a tenant.

- **Purpose:** global organizational context
- **Schema:** keys are defined at tenant creation (via `tenant_metadata_schema`)
- **Stability:** keys are immutable to prevent schema drift
- **Best for:** compliance, business unit, region, retention policy, data classification

Example:

```
{
  "tenant_metadata_schema": [
    {"key": "compliance_framework", "type": "string", "searchable": true},
    {"key": "data_classification", "type": "string", "searchable": true},
    {"key": "region", "type": "string", "searchable": true}
  ],
  "tenant_metadata": {
    "compliance_framework": "SOC2",
    "data_classification": "internal",
    "region": "us"
  }
}
```

### Document Metadata (`document_metadata`)

Document-level metadata that can vary across memories.

- **Purpose:** fine-grained filtering and discovery
- **Flexibility:** fully dynamic and mutable
- **Best for:** owner, project, status, source, created_at, tags, version

Example:

```
{
  "document_metadata": {
    "title": "API Security Guidelines",
    "project": "phoenix",
    "owner": "sarah.chen@acme.com",
    "status": "approved",
    "created_at": "2024-01-15T10:30:00Z",
    "tags": ["security", "api"]
  }
}
```

---

## Why Two Tiers?

This split gives you:

- **Organizational consistency** (tenant metadata)
- **Per-document flexibility** (document metadata)
- **Efficient filtering at scale** (metadata-first candidate retrieval)
- **Governance and isolation** (compliance-aware recall)

---

## Metadata Filtering

Metadata filters let you make retrieval deterministic.

Example user request:

> “All information related to Project Strawberry from last month.”

Deterministic filter:

```
{
  "document_metadata": {
    "project": "strawberry",
    "created_at": {"$gte": "2025-03-01", "$lt": "2025-04-01"}
  }
}
```

In Cortex recall, this filter is applied _before_ semantic and graph ranking.

### Common Filtering Patterns

- **Scope by ownership**: `owner = "nish@company.com"`
- **Scope by team/project**: `team = "engineering"`, `project = "phoenix"`
- **Time bounding**: `created_at`, `source_last_updated_time`
- **Compliance constraints**: `data_classification = "confidential"`
- **Source constraints**: `source_type = "gmail" | "slack" | "notion"`

---

## Supported Data Types

Metadata supports primitive and structured values:

- strings, numbers, booleans
- dates / datetimes (ISO 8601)
- arrays (tags, categories)
- nested objects (ownership, workflows)

**Tip:** keep metadata small and structured — avoid storing large text blobs in metadata.

---

## Reserved Keywords

The following keywords are reserved and cannot be used as keys in `tenant_metadata_schema`:

- `id`
- `source_title`, `source_url`, `source_type`, `source_collection`
- `source_owner`, `source_collaborator`
- `source_upload_time`, `source_last_updated_time`
- `chunk_id`, `chunk_uuid`, `chunk_content`
- `document_metadata`, `base_metadata`, `layout`, `description`

---

## Best Practices

- Use **snake_case** for keys and keep naming consistent.
- Prefer **booleans** for binary flags (e.g., `is_confidential: true`).
- Use **arrays** instead of comma-separated strings for tags.
- Include stable identifiers where possible (emails, ticket IDs, URLs).
- Design metadata so it mirrors how users actually ask questions.

---

## How Metadata Fits Into Recall

Cortex recall is multi-stage:

1. **Metadata filters** scope the candidate set (deterministic)
2. **Hybrid retrieval** (keyword / regex / embeddings) expands relevant context
3. **Graph traversal** adds relational structure
4. **Personalized ranking** chooses what is most useful for the task

This is how Cortex avoids the classic RAG failure mode:

> “Semantically similar, but practically useless.”

Metadata ensures retrieval is precise, auditable, and production-ready — while Cortex intelligence determines what matters most inside the allowed scope.