---
title: "Core Concepts"
description: "Understand the core concepts of using Cortex"
---

The Cortex SDK is designed to give you the most flexible developer experience for building AI apps and agents. Set up a global memory store for individual users (B2C), or configure organizations as tenants and onboard their users (B2B).

# Core Concepts

## Memories (Users and Knowledge)

These are the atoms that make up the context store for your agents. This includes any type of documents, emails, messages, images, webpages, presentations, reports, users' preferences, likes, dislikes, discussions, and any form of unstructured information. Cortex also digests simple CSVs. Each memory you add is meticulously parsed and prepared for the most optimal recall experience for your agents.

## Recall: Why you need a personalized store for every agent

Recall is the most critical part of a memory system. Storing memories is hard — knowing what to retrieve, when to retrieve it, and why is harder.

Cortex is built around the idea that recall needs to feel **intelligent, personalized, and context-aware**, not just a naive search over embeddings.

When an agent queries Cortex, the system doesn’t simply return the closest vectors. Instead, Cortex performs a multi-stage retrieval process that:

- Understands the **intent of the query**
- Considers the **user, tenant, and agent context**
- Traverses the graph to understand **relationships, linkages, and historical outcomes**
- Weighs **recency, relevance, frequency, and semantic similarity**
- Ranks memories based on **how useful they are for the current task**

### This Is What Makes Cortex Different

Traditional RAG systems treat memory like a flat database. Cortex treats memory like a **living context graph**.

Each recall operation takes into account:

- **Who** is asking (user-specific personalization)
- **Which agent** is asking (agent role and capabilities)
- **What they’re trying to do** (task and intent)
- **What has worked before** (historical usage patterns)

This allows Cortex to return not just _relevant_ information, but the **most useful information for that exact interaction**.

### Adaptive & Personalized Retrieval

Over time, Cortex learns which memories are actually helpful for a given user or workflow. This enables:

- **Personalized ranking** — two users asking the same question may get different context.
- **Implicit feedback loops** — memories that are frequently used, referenced, or lead to successful outcomes are prioritized.
- **Contextual pruning** — low-signal or redundant memories are automatically deprioritized.

Think of it less like search, and more like a **personalized context engine** that continuously optimizes what your agents see.

### We belive in going beyond vector search

Pure vector search has repeatedly failed to provide reliable enterprise-grade context on its own. Research from Google DeepMind and Stanford shows that embedding-only retrieval systems often surface irrelevant, outdated, or misleading information, especially in complex knowledge workflows.

Cortex is built on the belief that vector databases alone are not enough for memory. Every agent needs its own **personalized recall layer** that combines semantic understanding with structured signals, behavioral feedback, and graph-based relationships.

Rather than asking "What is semantically similar?", Cortex asks:

- What information is **most likely to help this agent succeed right now?**
- What context has **actually worked in the past?**
- What should be **ignored, deprioritized, or filtered out?**

The result is a recall system that feels closer to a **personalized PageRank for memory** than a traditional vector database.

## Tenants

Think of a **tenant** as a complete workspace or organization in your Cortex application. It's like having different "companies" or "projects" that can't see each other's data.

**Simple Analogy**: Imagine you're building a knowledge management system for multiple companies. Each company gets their own "tenant" - like separate office buildings where employees can't access each other's files.

Cortex supports both **B2C** and **B2B** use cases:

- **B2C (Business-to-Consumer)**: Each individual user gets their own private space within your single tenant. Perfect for personal AI assistants or individual productivity apps. Achieve this by assigning each user their own sub-tenant. 
- **B2B (Business-to-Business)**: Each organization gets their own tenant with complete data isolation. Perfect for software serving multiple companies.

### Sub-Tenants

A **sub-tenant** is like a department or team within an organization. It provides an additional layer of organization within a tenant.

**Simple Analogy**: If a tenant is like a company, then sub-tenants are like departments (Engineering, Sales, HR) within that company. Each department has its own space, but they're all part of the same company.

**Key Benefits**:

- **Complete Data Isolation**: No tenant can ever see another tenant's data
- **Organized Workspaces**: Sub-tenants help organize data within large organizations
- **Flexible Access Control**: Control who can access what data at both tenant and sub-tenant levels
- **Scalable Architecture**: Serve unlimited organizations and their subdivisions

**How It Works**:

1. **First Upload**: When you upload context with a new `sub_tenant_id`, Cortex automatically creates that sub-tenant
2. **Immediate Availability**: The sub-tenant is immediately available for all subsequent operations
3. **No Setup Required**: No configuration or setup is needed - just start using the new `sub_tenant_id`

**Best Practice - Use User IDs for B2C Applications**:

```javascript
// For individual user workspaces, use user IDs as sub-tenant IDs
sub_tenant_id: "user_12345"    // User's personal workspace
sub_tenant_id: "user_67890"    // Another user's workspace
```

**Best Practice - Use Descriptive Names for B2B Applications**:

```javascript
// For organizational subdivisions, use descriptive names
sub_tenant_id: "engineering"   // Engineering department
sub_tenant_id: "sales"         // Sales team
sub_tenant_id: "hr"            // Human Resources
```

## Metadata: Structuring Memory for Deterministic Retrieval

Metadata allows you to structure and filter retrieval with precision. While semantic recall is powerful, many real-world workflows require **deterministic control** — the ability to explicitly include or exclude memories based on known attributes.

With Cortex, you can attach arbitrary key-value metadata to memories and use them as hard filters or ranking signals during recall. This is especially useful when you want predictable behavior across teams, products, or workflows.

For example, a user might request:

> "All information related to the project Strawberry"

This can be resolved deterministically by filtering on:

project = "strawberry"

before any semantic or graph-based ranking is applied.

### Tenant Metadata

Organization-level metadata that applies consistently across all memories within a tenant. This is useful for enforcing global constraints and isolation.

Common examples:

- `company_id`
- `org_name`
- `region`
- `data_sensitivity`

Tenant metadata ensures that recall always respects **organizational boundaries and policies**.

### Memory Metadata

Document-level metadata that varies from memory to memory. This enables fine-grained filtering and control over retrieval.

Common examples:

- `user_id`
- `team`
- `project`
- `source` (slack, gmail, notion, api)
- `timestamp`
- `tags`

Memory metadata allows you to scope recall to **specific users, teams, time ranges, or data sources**.

### Metadata Filtering

Metadata filters can be applied at query time to control what Cortex is allowed to retrieve.

You can use metadata to:

- Restrict recall to a specific user or team
- Filter by product, project, or workflow
- Enforce time-based constraints ("last 30 days")
- Build deterministic pipelines for compliance or auditing