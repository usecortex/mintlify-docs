---
title: "SDKs - Node and Python"
description: "Official TypeScript/Node.js and Python SDKs so that you can integrate Cortex AI into your application with ease."
---

## Installation

<Tabs>
  <Tab title="TypeScript / Node.js">
    ```bash
    npm i @usecortex_ai/node
    ```
  </Tab>
  <Tab title="Python">
    ```bash
    pip install usecortex-ai
    ```
  </Tab>
</Tabs>

## Client Setup

<Tabs>
  <Tab title="TypeScript">
    ```ts
    import { CortexAIClient } from "@usecortex_ai/node";
    
    const client = new CortexAIClient({
      token: process.env.CORTEX_API_KEY,
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    import os
    from usecortex_ai import CortexAI, AsyncCortexAI
    
    api_key = os.environ["CORTEX_API_KEY"]
    
    # Sync client
    client = CortexAI(token=api_key)
    
    # Async client (for async/await usage)
    async_client = AsyncCortexAI(token=api_key)
    ```
  </Tab>
</Tabs>

<Info>
  **Python**: We provide both synchronous and asynchronous clients. Use `AsyncCortexAI` for async/await patterns and `CortexAI` for traditional synchronous operations.
</Info>

## SDK Method Structure & Type Safety

Our SDKs follow a predictable pattern that mirrors the API structure while providing full type safety:

<Note>
  **Method Mapping**: `client.<group>.<function_name>` mirrors `api.usecortex.ai/<group>/<function_name>`

  For example: `client.upload.addMemory()` corresponds to `POST /upload/add_memory`
</Note>

### Input and Output Type Matching

The SDKs provide exact type parity with the API specification:

- **Request Parameters**: Every field documented in the API reference (required, optional, types, validation rules) is reflected in the SDK method signatures
- **Response Objects**: Return types match the exact JSON schema documented for each endpoint
- **Error Types**: Exception structures mirror the error response formats from the API
- **Nested Objects**: Complex nested parameters and responses maintain their full structure and typing

### Parameter Naming

The REST API uses **snake_case** for all request and response body fields (e.g. `tenant_id`, `sub_tenant_id`). The SDKs handle naming as follows:

- **TypeScript SDK**: Uses **camelCase** for parameter names (e.g. `tenantId`, `subTenantId`) to match JavaScript conventions. The SDK maps these to the API's snake_case when sending requests.
- **Python SDK**: Uses **snake_case** for parameters, matching the API.

When calling the REST API directly (e.g. with curl), use snake_case. In TypeScript examples throughout the docs, we show the SDK's camelCase parameters. This means you can rely on your IDE's autocomplete and type checking. If a parameter is optional in the API docs, it's optional in the SDK. If a response contains a specific field, your IDE will know about it.

## Getting Started

Let's walk through a complete example from creating a tenant to searching your data.

### Step 1: Create a Tenant

<Tabs>
  <Tab title="TypeScript">
    ```ts
    async function createTenant() {
      const tenantCreationResponse = await client.user.createTenant({
        tenant_id: "my-company"
      });
      return tenantCreationResponse;
    }
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    def create_tenant():
        return client.user.create_tenant(tenant_id="my-company")
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    async def create_tenant():
        return await async_client.user.create_tenant(tenant_id="my-company")
    ```
  </Tab>
</Tabs>

### Step 2: Getting your context store ready

Now let's upload some context:

<Tabs>
  <Tab title="TypeScript">
    ```ts
    // Upload text content
    async function uploadKnowledge() {
      const res = await client.upload.uploadKnowledge({
        tenant_id: "my-company",
        sub_tenant_id: "engineering",
        body: {
          content: "Our API rate limits are 1000 requests per minute for premium accounts.",
          id: "api-docs-rate-limits",
          tenant_metadata: { sub_tenant_id: "engineering" }
        }
      });
      return res;
    }
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    # Upload text content
    def upload_text():
        return client.upload.upload_text(
            tenant_id="my-company-py-sync",
            sub_tenant_id="engineering",
            content="Our API rate limits are 1000 requests per minute for premium accounts.",
            id="api-docs-rate-limits",
            tenant_metadata={"sub_tenant_id": "engineering"}
        )
    
    # Upload document file
    def upload_file():
        with open("company-handbook.pdf", 'rb') as file_obj:
            file_data = ("company-handbook.pdf", file_obj)
            return client.upload.upload_document(
                tenant_id="my-company",
                file=file_data,
                id="company-handbook.pdf"
            )
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    # Upload text content
    async def upload_text():
        return await async_client.upload.upload_text(
            tenant_id="my-company",
            sub_tenant_id="engineering",
            content="Our API rate limits are 1000 requests per minute for premium accounts.",
            id="api-docs-rate-limits",
            tenant_metadata={"sub_tenant_id": "engineering"}
        )
    
    # Upload document file
    async def upload_file():
        with open("company-handbook.pdf", 'rb') as file_obj:
            file_data = ("company-handbook.pdf", file_obj)
            return await async_client.upload.upload_document(
                tenant_id="my-company",
                file=file_data,
                id="company-handbook.pdf"
            )
    ```
  </Tab>
</Tabs>

### Step 3: Recall

<Tabs>
  <Tab title="TypeScript">
    ```ts
    // Semantic search with retrieval
    const results = await client.search.recall({
      query: "What are the API rate limits?",
      tenant_id: "my-company",
      sub_tenant_id: "engineering"
    });
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    # Semantic search with retrieval
    results = client.search.retrieve(
        query="What are the API rate limits?",
        tenant_id="my-company",
        sub_tenant_id="engineering",
        max_chunks=10
    )
    
    # List all sources
    all_sources = client.sources.get_all(
        tenant_id="my-company",
        sub_tenant_id="engineering",
    )
    
    # Get specific sources by ID
    specific_sources = client.sources.get_by_ids(
        tenant_id="my-company",
        sub_tenant_id="engineering",
        ids=["api-docs-rate-limits", "company-handbook"]
    )
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    # Semantic search with retrieval
    results = await async_client.search.retrieve(
        query="What are the API rate limits?",
        tenant_id="my-company",
        sub_tenant_id="engineering",
        max_chunks=10
    )
    
    # List all sources
    all_sources = await async_client.sources.get_all(
        tenant_id="my-company",
        sub_tenant_id="engineering",
    )
    
    # Get specific sources by ID
    specific_sources = await async_client.sources.get_by_ids(
        tenant_id="my-company",
        sub_tenant_id="engineering",
        ids=["api-docs-rate-limits", "company-handbook"]
    )
    ```
  </Tab>
</Tabs>

## Additional Endpoints

### List Sources

<Info>
  The `/list` endpoints use special naming in the SDKs for better developer experience:

  - `/list/memories` → `memories.getAll()` / `memories.get_all()`
  - `/list/knowledge` → `knowledge.getByIds()` / `knowledge.get_by_ids()`
</Info>

## Type Safety

<Check>
  All SDKs are fully typed with TypeScript definitions and Python type hints. Your IDE will provide:

  - **Autocomplete** for all method names and parameters
  - **Type checking** for request and response objects
  - **Inline documentation** for each parameter
  - **Error prevention** through compile-time validation
</Check>

## Error Handling

Both SDKs throw exceptions for API errors. The error objects contain the same structure as documented in our [Error Responses](/api-reference/error-responses) section.

### The Universal CMD+Space Approach

Whether you're using **TypeScript**, **Python**, **VS Code**, **PyCharm**, or **any modern IDE**, the approach is identical:

1. **Type the method name** → See all available methods
2. **Open the parentheses** → See all required and optional parameters
3. **Press Cmd+Space (Mac) or Ctrl+Space (Windows/Linux)** → Get instant documentation

This works universally because our SDKs are fully typed with comprehensive documentation.

<Tabs>
  <Tab title="TypeScript">
    ```ts
    // Start typing and your IDE will guide you through everything:
    client.recall({
      // - Cmd+Space here shows all parameters with documentation
      query: "your search query",
      tenant_id: "required-tenant-id"
    })
    ```
  </Tab>
  <Tab title="Python">
    ```python
    # Identical experience - your IDE shows everything:
    client.recall(
        # - Ctrl+Space here shows all parameters with type hints
        query="your search query", 
        tenant_id="required-tenant-id",
        # Python IDE knows these are optional too:
        max_chunks=10,
        alpha=0.7
    )
    ```
  </Tab>
</Tabs>