---
title: "SDKs - Node and Python"
description: "Official TypeScript/Node.js and Python SDKs for the Cortex AI platform. Build powerful, context-aware AI applications."
---

## Installation

<Tabs>
  <Tab title="TypeScript / Node.js">
    ```bash
    npm i @usecortex_ai/node
    ```
  </Tab>
  <Tab title="Python">
    ```bash
    pip install usecortex-ai
    ```
  </Tab>
</Tabs>

## Client Setup

<Tabs>
  <Tab title="TypeScript">
    ```ts
    import { CortexAIClient } from "@usecortex_ai/node";
    
    const client = new CortexAIClient({
      token: process.env.CORTEX_API_KEY,
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    import os
    from usecortex_ai import CortexAI, AsyncCortexAI
    
    api_key = os.environ["CORTEX_API_KEY"]
    
    # Sync client
    client = CortexAI(token=api_key)
    
    # Async client (for async/await usage)
    async_client = AsyncCortexAI(token=api_key)
    ```
  </Tab>
</Tabs>

<Info>
  **Python**: We provide both synchronous and asynchronous clients. Use `AsyncCortexAI` for async/await patterns and `CortexAI` for traditional synchronous operations.
</Info>

## SDK Method Structure & Type Safety

Our SDKs follow a predictable pattern that mirrors the API structure while providing full type safety.

> **Method Mapping** : `client.<group>.<function_name>` mirrors  `api.usecortex.ai/<group>/<function_name>` 

The SDKs provide exact type parity with the API specification:

- **Request Parameters**: Every field documented in the API reference (required, optional, types, validation rules) is reflected in the SDK method signatures
- **Response Objects**: Return types match the exact JSON schema documented for each endpoint
- **Error Types**: Exception structures mirror the error response formats from the API
- **Nested Objects**: Complex nested parameters and responses maintain their full structure and typing

### Parameter Naming

The REST API uses **snake_case** for all request and response body fields (e.g. `tenant_id`, `sub_tenant_id`). The SDKs handle naming as follows:

- **TypeScript SDK**: Uses **camelCase** for parameter names (e.g. `tenantId`, `subTenantId`) to match JavaScript conventions. The SDK maps these to the API's snake_case when sending requests.
- **Python SDK**: Uses **snake_case** for parameters, matching the API.

When calling the REST API directly (e.g. with curl), use snake_case. In TypeScript examples throughout the docs, we show the SDK's camelCase parameters. This means you can rely on your IDE's autocomplete and type checking. If a parameter is optional in the API docs, it's optional in the SDK. If a response contains a specific field, your IDE will know about it.

## Getting Started

### Create a Tenant

You can consider a `tenant` as a single database that can have internal isolated collections called `sub-tenants`. [Know more about the concept of tenant here](https://docs.usecortex.ai/essentials/multi-tenant)

<Tabs>
  <Tab title="TypeScript">
    ```ts
    async function createTenant() {
      const tenantCreationResponse = await client.tenant.create({
        tenant_id: "my-company"
      });
      return tenantCreationResponse;
    }
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    def create_tenant():
        return client.tenant.create(tenant_id="my-company")
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    async def create_tenant():
        return await async_client.tenant.create(tenant_id="my-company")
    ```
  </Tab>
</Tabs>

### Ingest Your Data

When you index your data, you make it ready for retrieval from Cortex using natural language.

#### Knowledge Base

Upload documents, PDFs, and other content to your knowledge base for semantic search and retrieval.

<Tabs>
  <Tab title="TypeScript">
    ```ts
    // Add to your knowledge base
    import fs from 'fs';

    const uploadResult = await client.upload.knowledge({
      files: [
        fs.readFileSync("a.pdf"),
        fs.readFileSync("b.pdf")
      ],
      tenant_id: "tenant_123",
      file_metadata: [
        {
          id: "doc_a",
          tenant_metadata: { dept: "sales" },
          document_metadata: { author: "Alice" },
          relations: false
        },
        {
          id: "doc_b",
          tenant_metadata: { dept: "marketing" },
          document_metadata: { author: "Bob" },
          relations: true
        }
      ]
    });
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    # ingest in your knowledge base
    with open("a.pdf", 'rb') as f1, open("b.pdf", 'rb') as f2:
        files = [
            ("a.pdf", f1),
            ("b.pdf", f2)
        ]
        upload_result = client.upload.knowledge(
            tenant_id="tenant_123",
            files=files,
            file_metadata=[
                {
                    "id": "doc_a",
                    "tenant_metadata": {"dept": "sales"},
                    "document_metadata": {"author": "Alice"}
                },
                {
                    "id": "doc_b",
                    "tenant_metadata": {"dept": "marketing"},
                    "document_metadata": {"author": "Bob"}
                }
            ]
        )
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    # ingest in your knowledge base
    async def upload_knowledge():
        with open("a.pdf", 'rb') as f1, open("b.pdf", 'rb') as f2:
            files = [
                ("a.pdf", f1),
                ("b.pdf", f2)
            ]
            return await async_client.upload.knowledge(
                tenant_id="tenant_123",
                files=files,
                file_metadata=[
                    {
                        "id": "doc_a",
                        "tenant_metadata": {"dept": "sales"},
                        "document_metadata": {"author": "Alice"}
                    },
                    {
                        "id": "doc_b",
                        "tenant_metadata": {"dept": "marketing"},
                        "document_metadata": {"author": "Bob"}
                    }
                ]
            )
    ```
  </Tab>
</Tabs>

> **For a more detailed explanation** of document upload, including supported file formats, processing pipeline, metadata handling, and advanced configuration options, refer to the [Ingest Knowledge](https://docs.usecortex.ai/api-reference/endpoint/add-knowledge-memories).


#### User Memories

Store user preferences, conversation history, and personalized context that evolves with every interaction.

<Tabs>
  <Tab title="TypeScript">
    ```ts expandable
    // Simple text memory
    const result = await client.userMemory.add({
      memories: [
        {
          text: "User prefers detailed explanations and dark mode",
          infer: true,
          user_name: "John"
        }
      ],
      tenant_id: "tenant-01",
      sub_tenant_id: "",
      upsert: true
    });

    // Markdown content
    const markdownResult = await client.userMemory.add({
      memories: [
        {
          text: "# Meeting Notes\n\n## Key Points\n- Budget approved\n- Launch date: Q2",
          is_markdown: true,
          infer: false,
          title: "Meeting Notes"
        }
      ],
      tenant_id: "tenant-01",
      sub_tenant_id: "",
      upsert: true
    });

    // User-assistant pairs with inference
    const conversationResult = await client.userMemory.add({
      memories: [
        {
          user_assistant_pairs: [
            { user: "What are my preferences?", assistant: "You prefer dark mode and detailed explanations." },
            { user: "How do I like my reports?", assistant: "You prefer weekly summary reports with charts." }
          ],
          infer: true,
          user_name: "John",
          custom_instructions: "Extract user preferences"
        }
      ],
      tenant_id: "tenant-01",
      sub_tenant_id: "",
      upsert: true
    });
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python expandable
    # Simple text memory
    result = client.user_memory.add(
        memories=[
            {
                "text": "User prefers detailed explanations and dark mode",
                "infer": True,
                "user_name": "John"
            }
        ],
        tenant_id="tenant-01",
        sub_tenant_id="",
        upsert=True
    )

    # Markdown content
    markdown_result = client.user_memory.add(
        memories=[
            {
                "text": "# Meeting Notes\n\n## Key Points\n- Budget approved",
                "is_markdown": True,
                "infer": False,
                "title": "Meeting Notes"
            }
        ],
        tenant_id="tenant-01",
        sub_tenant_id="",
        upsert=True
    )

    # User-assistant pairs with inference
    conversation_result = client.user_memory.add(
        memories=[
            {
                "user_assistant_pairs": [
                    {"user": "What are my preferences?", "assistant": "You prefer dark mode."},
                    {"user": "How do I like reports?", "assistant": "Weekly summaries with charts."}
                ],
                "infer": True,
                "user_name": "John",
                "custom_instructions": "Extract user preferences"
            }
        ],
        tenant_id="tenant-01",
        sub_tenant_id="",
        upsert=True
    )
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python expandable
    # Simple text memory
    async def add_memories():
        return await async_client.user_memory.add(
            memories=[
                {
                    "text": "User prefers detailed explanations and dark mode",
                    "infer": True,
                    "user_name": "John"
                }
            ],
            tenant_id="tenant-01",
            sub_tenant_id="",
            upsert=True
        )
    ```
  </Tab>
</Tabs>


### Recall

<Tabs>
  <Tab title="TypeScript">
    ```ts
    // Search across memories/knowledge base
    const results = await client.recall.fullRecall({
      query: "Which mode does user prefer",
      tenantId: "tenant_1234",
      subTenantId: "sub_tenant_4567",
      alpha: 0.8,
      recencyBias: 0
    });

    // List all the data (memories + knowledge base)
    const allSources = await client.data.listData({
      tenant_id: "tenant_1234",
      sub_tenant_id: "sub_tenant_4567"
    });
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    # Semantic Recall
    results = client.recall.full_recall(
        query="Which mode does user prefer",
        tenant_id="tenant_1234",
        sub_tenant_id="sub_tenant_4567",
        alpha=0.8,
        recency_bias=0
    )

    # Get ingested data (memories + knowledge base)
    all_sources = client.data.list_data(
        tenant_id="tenant_1234",
        sub_tenant_id="sub_tenant_4567"
    )
    ```
  </Tab>
  <Tab title="Python (Async)">
    ```python
    # Semantic Recall
    async def search_data():
        results = await async_client.recall.full_recall(
            query="Which mode does user prefer",
            tenant_id="tenant_1234",
            sub_tenant_id="sub_tenant_4567",
            alpha=0.8,
            recency_bias=0
        )
        return results

    # Get ingested data (memories + knowledge base)
    async def list_data():
        all_sources = await async_client.data.list_data(
            tenant_id="tenant_1234",
            sub_tenant_id="sub_tenant_4567"
        )
        return all_sources
    ```
  </Tab>
</Tabs>

## Additional Endpoints

### List Sources

<Info>
  The `/list` endpoints use special naming in the SDKs for better developer experience:

  - `/list/memories` → `memories.getAll()` / `memories.get_all()`
  - `/list/knowledge` → `knowledge.getByIds()` / `knowledge.get_by_ids()`
</Info>

## Type Safety

<Check>
  All SDKs are fully typed with TypeScript definitions and Python type hints. Your IDE will provide:

  - **Autocomplete** for all method names and parameters
  - **Type checking** for request and response objects
  - **Inline documentation** for each parameter
  - **Error prevention** through compile-time validation
</Check>

## Error Handling

Both SDKs throw exceptions for API errors. The error objects contain the same structure as documented in our [Error Responses](/api-reference/error-responses) section.

### The Universal CMD+Space Approach

Whether you're using **TypeScript**, **Python**, **VS Code**, **PyCharm**, or **any modern IDE**, the approach is identical:

1. **Type the method name** → See all available methods
2. **Open the parentheses** → See all required and optional parameters
3. **Press Cmd+Space (Mac) or Ctrl+Space (Windows/Linux)** → Get instant documentation

This works universally because our SDKs are fully typed with comprehensive documentation.
