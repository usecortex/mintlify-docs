---
title: "Knowledge Base"
description: "Your users won't tell AI everything. But their Slack messages, Notion docs, emails, and drives already contain the context your agents need. Knowledge Memories lets you ingest, store, and recall all of this - creating a unified context layer for every user. When combined with User Memories, your agents deliver hyper-personalized responses with the right context."
openapi: "POST /ingestion/upload_knowledge"
---

### Examples

<Tabs>
  <Tab title="API Request">
    ```bash
    # File Upload Example
    curl -X POST https://api.usecortex.ai/ingestion/upload_knowledge \
    -F "tenant_id=tenant_123" \
    -F "files=@a.pdf" \
    -F "files=@b.pdf" \
    -F 'file_metadata=[
    {
      "id": "doc_a",
      "tenant_metadata": { "dept": "sales" },
      "document_metadata": { "author": "Alice" },
      "relations": false
    },
    {
      "id": "doc_b",
      "tenant_metadata": { "dept": "marketing" },
      "document_metadata": { "author": "Bob" },
      "relations": true
    }
    ]'

    # App Knowledge Upload Example
    curl -X POST https://api.usecortex.ai/ingestion/upload_knowledge \
    -H 'Content-Type: application/json' \
    -d '{
      "app_knowledge": [
        {
          "id": "doc_a",
          "tenant_id": "tenant_123",
          "sub_tenant_id": "sub_tenant_456",
          "title": "Sales Report Q1",
          "source": "gmail",
          "description": "Quarterly sales performance report",
          "url": "https://mail.google.com/view/abc123",
          "timestamp": "2024-01-15T10:30:00Z",
          "content": {
            "text": "Sales data for Q1 2024 shows a 15% increase..."
          },
          "metadata": {
            "dept": "sales"
          },
          "additional_metadata": {
            "author": "Alice",
            "priority": "high"
          },
          "relations": true
        }
      ]
    }'
    ```
  </Tab>
  <Tab title="TypeScript">
    ```ts
    // File Upload Example
    import fs from 'fs';
    
    const uploadResult = await client.upload.knowledge({
      files: [
        fs.readFileSync("a.pdf"),
        fs.readFileSync("b.pdf")
      ],
      tenant_id: "tenant_123",
      file_metadata: [
        {
          id: "doc_a",
          metadata: { dept: "sales" },
          additional_metadata: { author: "Alice" },
          relations: {"cortex_source_ids": ["source_id_1", "source_id_2"]}
        },
        {
          id: "doc_b",
          metadata: { dept: "marketing" },
          additional_metadata: { author: "Bob" },
          relations: {"cortex_source_ids": ["source_id_3", "source_id_4"]}
        }
      ]
    });

    // App Knowledge Upload Example
    const appUploadResult = await client.upload.knowledge({
      app_knowledge: [
        {
          id: "doc_a",
          tenant_id: "tenant_123",
          sub_tenant_id: "sub_tenant_456",
          title: "Sales Report Q1",
          source: "gmail",
          description: "Quarterly sales performance report",
          url: "https://mail.google.com/view/abc123",
          timestamp: "2024-01-15T10:30:00Z",
          content: { 
            text: "Sales data for Q1 2024 shows a 15% increase..."
          },
          metadata: { dept: "sales" },
          additional_metadata: { 
            author: "Alice",
            priority: "high"
          },
          relations: {"cortex_source_ids": ["source_id_1", "source_id_2"]}
        }
      ]
    });
    ```
  </Tab>
  <Tab title="Python (Sync)">
    ```python
    # File Upload Example
    # Async usage is similar, just use async_client and await
    with open("a.pdf", 'rb') as f1, open("b.pdf", 'rb') as f2:
        files = [
            ("a.pdf", f1),
            ("b.pdf", f2)
        ]
        upload_result = client.upload.knowledge(
            tenant_id="tenant_123",
            files=files,
            file_metadata=[
                {
                    "id": "doc_a",
                    "metadata": {"dept": "sales"},
                    "additional_metadata": {"author": "Alice"},
                    "relations": {"cortex_source_ids": ["source_id_1", "source_id_2"]}
                },
                {
                    "id": "doc_b",
                    "metadata": {"dept": "marketing"},
                    "additional_metadata": {"author": "Bob"},
                    "relations": {"cortex_source_ids": ["source_id_3", "source_id_4"]}
                }
            ]
        )

    # App Knowledge Upload Example
    # Async usage is similar, just use async_client and await
    app_upload_result = client.upload.knowledge(
        app_knowledge=[
            {
                "id": "doc_a",
                "tenant_id": "tenant_123",
                "sub_tenant_id": "sub_tenant_456",
                "title": "Sales Report Q1",
                "source": "gmail",
                "description": "Quarterly sales performance report",
                "url": "https://mail.google.com/view/abc123",
                "timestamp": "2024-01-15T10:30:00Z",
                "content": {
                    "text": "Sales data for Q1 2024 shows a 15% increase..."
                },
                "metadata": {
                    "dept": "sales"
                },
                "additional_metadata": {
                    "author": "Alice",
                    "priority": "high"
                },
                "relations": {"cortex_source_ids": []}
            }
        ]
    )
    ```
  </Tab>
</Tabs>

This endpoint supports two types of uploads:

1. **File Uploads**: Upload documents (PDF, DOCX, TXT, etc.) using multipart form data
2. **App Knowledge Uploads**: Upload structured knowledge from workplace apps using JSON with the AppKnowledgeModel format

## File Upload Parameters

When uploading files, you can provide metadata for each file using the `file_metadata` parameter. This allows you to associate custom metadata, organize documents, and control processing behavior on a per-file basis.

### `file_metadata` Array

The `file_metadata` parameter accepts a JSON array where each object corresponds to one of the uploaded files. The order of metadata objects should match the order of files in the `files` parameter.

**Structure:**

```json
[
  {
    "id": "string",
    "metadata": {},
    "additional_metadata": {},
    "relations": {"cortex_source_ids": []}
  }
]
```

### File Metadata Fields

#### `id` (string, optional)

- **Description**: A unique identifier for the document. If not provided, the system will auto-generate one.
- **Use Case**: Use this to reference the document later, enable idempotent uploads, or maintain your own document naming scheme.
- **Example**: `"doc_a"`, `"invoice_2024_001"`, `"manual_v2.3"`

#### `metadata` (object, optional)

- **Description**: Key-value pairs that represent tenant-level metadata. This metadata is shared across all documents within the tenant and is useful for organization-wide filtering and categorization.
- **Use Case**: Store department information, project tags, organizational units, or any tenant-scoped attributes that help organize and filter documents.
- **Example**:

  ```json
  {
    "dept": "sales",
    "project": "Q4_2024",
    "region": "us-west"
  }
  ```

#### `additional_metadata` (object, optional)

- **Description**: Key-value pairs that represent document-specific metadata. This metadata is unique to each document and provides context about the document itself.
- **Use Case**: Store document-specific information like author, creation date, document type, version, or any attributes that describe the individual document.
- **Example**:

  ```json
  {
    "author": "Alice",
    "created_date": "2024-01-15",
    "document_type": "invoice",
    "version": "1.0"
  }
  ```

#### `relations` (object, optional)

- **Description**: Object containing `cortex_source_ids` array that specifies source IDs the current source has relations with. When provided, the system will create relationships between the current source and the specified source IDs.
- **Use Case**: Create explicit relationships between documents for knowledge graph connections.
- **Default**: `{"cortex_source_ids": []}` (empty array - no relations)
- **Example**:
  - `{"cortex_source_ids": ["source_id_1", "source_id_2"]}`: Create relations to sources with those IDs
  - `{"cortex_source_ids": []}`: No relations

<Info>
  **Metadata Ordering**: The order of objects in the `file_metadata` array should match the order of files in the `files` parameter. The first metadata object applies to the first file, the second to the second file, and so on.
</Info>

## AppKnowledgeModel Parameters

The `app_knowledge` parameter accepts an array of `AppKnowledgeModel` objects. Each object represents a knowledge source from a workplace app with comprehensive metadata and content.

### `app_knowledge` Array Structure

```json
[
  {
    "id": "string",
    "tenant_id": "string",
    "sub_tenant_id": "string",
    "title": "string",
    "source": "string",
    "description": "string",
    "url": "string",
    "timestamp": "string",
    "content": {},
    "metadata": {},
    "additional_metadata": {},
    "relations": boolean
  }
]
```

### AppKnowledgeModel Fields

#### `id` (string, required)

- **Description**: Stable, unique identifier for the source. If omitted, one may be generated upstream.
- **Use Case**: Use this to reference the knowledge source later, enable idempotent uploads, or maintain your own naming scheme.
- **Example**: `"doc_a"`, `"gmail_thread_123"`, `"notion_page_456"`

#### `tenant_id` (string, required)

- **Description**: Unique identifier for the tenant.
- **Use Case**: Associates the knowledge source with a specific tenant for multi-tenant isolation.

#### `sub_tenant_id` (string, required)

- **Description**: Unique identifier for the sub-tenant.
- **Use Case**: Provides additional granularity for organizing knowledge within larger organizations.

#### `title` (string, optional, default: "")

- **Description**: Short human-readable title for the source.
- **Use Case**: Provides a quick, readable identifier for the knowledge source.
- **Example**: `"Sales Report Q1"`, `"Product Launch Discussion"`, `"Meeting Notes"`

#### `source` (string, optional, default: "")

- **Description**: Source of the knowledge (e.g., slack, gmail, notion).
- **Use Case**: Identifies the originating app or platform for the knowledge source.
- **Example**: `"gmail"`, `"slack"`, `"notion"`, `"drive"`, `"jira"`

#### `description` (string, optional, default: "")

- **Description**: Optional long-form description providing additional context.
- **Use Case**: Provides detailed information about the knowledge source content or purpose.
- **Example**: `"Quarterly sales performance report with detailed metrics"`

#### `url` (string, optional, default: "")

- **Description**: Canonical URL or reference link associated with the source.
- **Use Case**: Links back to the original source in the originating app.
- **Example**: `"https://mail.google.com/view/abc123"`, `"https://notion.so/xyz789"`

#### `timestamp` (string, optional, default: "")

- **Description**: Creation or last-updated timestamp of the source in ISO-8601 format.
- **Use Case**: Helps with temporal sorting and filtering of knowledge sources.
- **Example**: `"2024-01-15T10:30:00Z"`

#### `content` (ContentModel, optional, default: ContentModel())

- **Description**: Primary content payload used for indexing and retrieval.
- **Use Case**: Contains the actual content to be processed and indexed.
- **Structure**: Supports multiple content formats like text, HTML, CSV, markdown, files, and layout.

#### `metadata` (dict, optional, default: {})

- **Description**: Tenant-level metadata for organizing and filtering knowledge sources.
- **Use Case**: Store tenant-wide attributes like department, project, region, etc.
- **Example**:

  ```json
  {
    "dept": "sales",
    "project": "Q4_2024",
    "region": "us-west"
  }
  ```

#### `additional_metadata` (dict, optional, default: {})

- **Description**: Document-specific metadata for individual knowledge source context.
- **Use Case**: Store source-specific information like author, priority, tags, etc.
- **Example**:

  ```json
  {
    "author": "Alice",
    "priority": "high",
    "tags": ["urgent", "review"]
  }
  ```

#### `relations` (ForcefulRelationsPayload | null, optional, default: null)

- **Description**: Controls relationship extraction and knowledge graph creation.
- **Use Case**: When set, the system will analyze the content for entity relationships and create a knowledge graph.
- **Default**: `null` (no relationship extraction)
- **Example**: `true` for documents where understanding connections between entities is important.

<Info>
  **Content Model**: The `content` field in AppKnowledgeModel supports multiple formats including text, HTML (base64), CSV (base64), markdown, file attachments, and structured layouts. Choose the format that best represents your knowledge source content.
</Info>

## Supported Content Types

### File Uploads

<Info>
  **Supported Upload Formats**: For a comprehensive list of all supported file formats with detailed information, see our [Supported File Formats](/essentials/file-formats) documentation.
</Info>

<Warning>
  **Unsupported File Formats**: If you attempt to upload a file format that is not supported, you will receive an error response with status code `400` and the message: `"Unsupported file format: [filename]"`. Ensure your files are in a supported format before uploading.
</Warning>

### App Knowledge Sources

<Info>
  **Supported Apps**: The app_knowledge format supports knowledge from various workplace apps including Gmail, Slack, Notion, Drive, Jira, Confluence, and more. Each app type is processed using specialized pipelines to extract and normalize content effectively.
</Info>

<Warning>
  **Required Fields**: The `tenant_id` and `sub_tenant_id` fields are required for all app knowledge sources. Ensure these are provided for each item in the `app_knowledge` array.
</Warning>

## Document Processing Pipeline

When you upload content to Cortex, it is securely accepted and queued for processing, then automatically extracted, parsed, and cleaned to normalize structure and text. The content is intelligently chunked into semantically meaningful units with preserved metadata, enriched with embeddings for semantic understanding, indexed for hybrid retrieval (metadata, keyword, and vector search), and linked via cross-references to build relational context. Throughout the pipeline, quality checks validate extraction and embedding fidelity, ensuring the content is fully indexed, connected into the context graph, and ready for accurate, low-latency recall by your agents.

<Note>
  **Processing Time**: Most documents are fully processed and searchable within 1-5 minutes. Larger documents (100+ pages) may take up to 15 minutes. You can check processing status using the document ID returned in the response.
</Note>

### `Upsert` parameter (optional)

For file uploads, the identifier is `id` from `file_metadata`. For app knowledge uploads, the identifier is `id` from the AppKnowledgeModel. When that identifier already exists, `upsert` (boolean, default `true`) controls the behavior:

| Value   | Behavior                   |
| ------- | -------------------------- |
| `true`  | Replace existing (default) |
| `false` | Fail; do not overwrite     |

Overwriting permanently removes and replaces existing chunks, embeddings, and indexes for that identifier.

## Processing Status & Monitoring

After uploading, you can monitor your document's processing status:

### **Immediate Response**

**For File Uploads:**

```json
{
  "filename": "file_abc.pdf",
  "id": "doc_123456",
  "status": "queued"
}
```

**For App Knowledge Uploads:**

```json
{
  "processed": 2,
  "failed": 0,
  "ids": ["doc_a", "doc_b"],
  "status": "success"
}
```

### **Processing States**

Your content will progress through these states:

- **`queued`**: Content is in the processing queue, waiting to be processed
- **`in_progress`**: Content is actively being processed (includes content extraction, chunking, embedding generation, and indexing)
- **`success`**: Content is fully processed and searchable
- **`errored`**: Processing encountered an error (rare occurrence)

<Info>
  **In-Progress Details**: While the status shows `in_progress`, the system is actually performing multiple steps: app-specific content extraction, intelligent chunking, embedding generation, and database indexing. These happen sequentially but are all part of the single `in_progress` state.
</Info>

## Best Practices

### **Content Preparation**

**For File Uploads:**
- **File Size**: Documents up to 50MB are processed efficiently
- **Content Quality**: Clear, well-structured documents produce better embeddings
- **Metadata**: Include rich metadata for better filtering and organization

**For App Knowledge Uploads:**
- **Content Size**: Knowledge sources up to 50MB are processed efficiently
- **Content Quality**: Clear, well-structured content produces better embeddings
- **Metadata**: Include rich metadata for better filtering and organization
- **Source Identification**: Always specify the `source` field for proper processing pipeline selection

### **Processing Optimization**

**For File Uploads:**
- **Batch Uploads**: For multiple documents, include multiple files in a single request
- **Metadata Consistency**: Use consistent metadata schemas across your organization
- **File Naming**: Descriptive filenames help with document identification

**For App Knowledge Uploads:**
- **Batch Uploads**: For multiple knowledge sources, include them in a single `app_knowledge` array
- **Metadata Consistency**: Use consistent metadata schemas across your organization
- **Source Naming**: Use descriptive titles and clear source identification
- **Timestamp Accuracy**: Provide accurate timestamps for temporal search and filtering

### **Troubleshooting**

**Content Not Appearing in Search?**

- Wait 5-10 minutes for processing to complete
- Check if the content status is `errored` (rare occurrence)
- Verify your search query and filters
- For app knowledge uploads, ensure `tenant_id` and `sub_tenant_id` are correct

**Slow Processing?**

- Large content (100+ pages equivalent) take longer to process
- Complex content structures may require additional processing time
- High system load may temporarily slow processing

**Processing Failures?**

**For File Uploads:**
- If status shows `errored`, ensure your document isn't corrupted or password-protected
- Check that the file format is supported (see Supported File Formats section above)
- Verify your API key has sufficient permissions

**For App Knowledge Uploads:**
- If status shows `errored`, ensure your content data is valid and accessible
- Check that the `source` field specifies a supported app type
- Verify your API key has sufficient permissions
- Ensure required fields (`tenant_id`, `sub_tenant_id`) are provided`

<Info>
  **Need Help?** If content fails to process or you're experiencing issues, contact our support team with the `id` for assistance.
</Info>